<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Popstar Admin</title>
<style>
  :root {
    --bg: #0f0f10;
    --card: rgba(255,255,255,0.05);
    --border: rgba(255,255,255,0.12);
    --text: rgba(255,255,255,0.92);
    --muted: rgba(255,255,255,0.72);
    --muted2: rgba(255,255,255,0.60);
    --accent: #00ff88;
    --danger: #ff6b6b;
  }

  * { box-sizing: border-box; }
  body { margin:0; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg); color: var(--text); }
  .wrap { max-width: 980px; margin: 0 auto; padding: 36px 18px 60px; }
  .card { border: 1px solid var(--border); background: var(--card); border-radius: 18px; padding: 22px; }
  .head { display:flex; align-items:flex-start; justify-content: space-between; gap: 14px; }
  h1 { margin:0; font-size: 40px; letter-spacing: -0.02em; }
  .sub { margin-top: 6px; color: var(--muted); font-size: 13px; line-height: 1.35; }

  .grid { display:grid; grid-template-columns: 1fr; gap: 14px; margin-top: 18px; }

  label { display:block; font-size: 12px; color: var(--muted); margin: 0 0 6px; }
  input { width: 100%; height: 52px; border-radius: 12px; border: 1px solid rgba(0,0,0,0.2); background: #e9f0ff; padding: 0 14px; font-size: 16px; }
  .btnRow { display:flex; gap: 10px; flex-wrap: wrap; }
  button { height: 44px; border-radius: 12px; border: 0; padding: 0 14px; font-size: 14px; font-weight: 700; cursor: pointer; }
  .primary { background: var(--accent); color:#000; }
  .secondary { background: rgba(255,255,255,0.10); color:#fff; }
  button:disabled { opacity: 0.55; cursor: not-allowed; }

  .status { margin-top: 12px; font-size: 13px; color: var(--muted); white-space: pre-wrap; }
  .status.err { color: var(--danger); }

  .admin-area { display:none; margin-top: 18px; }
  .topbar { display:flex; align-items:center; justify-content: space-between; gap: 12px; padding: 14px 16px; border: 1px solid var(--border); background: rgba(255,255,255,0.03); border-radius: 14px; }
  .who { font-size: 13px; color: var(--muted); }
  .who strong { color: var(--text); font-weight: 700; }

  h2 { margin: 18px 0 10px; font-size: 16px; }
  .hint { font-size: 12px; color: var(--muted2); margin-bottom: 10px; }
  code { background: rgba(255,255,255,0.10); padding: 2px 6px; border-radius: 6px; }

  table { width:100%; border-collapse: collapse; overflow: hidden; border-radius: 14px; border: 1px solid var(--border); }
  thead th { text-align:left; font-size: 12px; color: var(--muted); font-weight: 700; padding: 10px 12px; background: rgba(255,255,255,0.04); }
  tbody td { font-size: 13px; padding: 10px 12px; border-top: 1px solid rgba(255,255,255,0.08); vertical-align: top; }
  .pill { display:inline-block; padding: 3px 10px; border-radius: 999px; background: rgba(255,255,255,0.10); font-size: 12px; }

  .badge { display:inline-flex; align-items:center; gap:6px; padding: 3px 10px; border-radius: 999px; font-size: 12px; border: 1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.08); }
  .dot { width:8px; height:8px; border-radius: 999px; background: rgba(255,255,255,0.55); display:inline-block; }
  .badge.pending  { border-color: rgba(255,255,255,0.18); }
  .badge.queued   { border-color: rgba(0,255,136,0.40); }
  .badge.active   { border-color: rgba(0,255,136,0.65); background: rgba(0,255,136,0.10); }
  .badge.ended    { border-color: rgba(255,255,255,0.14); opacity: .85; }
  .badge.rejected { border-color: rgba(255,107,107,0.65); background: rgba(255,107,107,0.10); }
  .badge.all      { border-color: rgba(255,255,255,0.14); }

  .empty { padding: 12px; color: var(--muted); font-size: 13px; border: 1px dashed rgba(255,255,255,0.18); border-radius: 14px; }

  .actionsCell { width: 240px; }
  .mini { height: 34px; font-size: 13px; border-radius: 10px; padding: 0 12px; }
  .mini.danger { background: rgba(255,107,107,0.92); color:#000; font-weight: 800; }

  @media (min-width: 760px) {
    .grid { grid-template-columns: 1fr 1fr; }
    .grid .full { grid-column: 1 / -1; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="head">
        <div>
          <h1>Popstar Admin</h1>
          <div class="sub">Password login + allowlist under RLS. Console client: <code>window.supa</code></div>
        </div>
        <div class="btnRow" id="headerBtns" style="display:none;">
          <button class="secondary" id="refreshBtn" type="button">Refresh</button>
          <button class="secondary" id="logoutBtn" type="button">Logout</button>
        </div>
      </div>

      <div id="loginArea">
        <div class="grid">
          <div>
            <label for="email">Email</label>
            <input id="email" type="email" autocomplete="email" placeholder="popstarrr@popstarrr.com" />
          </div>
          <div>
            <label for="password">Password</label>
            <input id="password" type="password" autocomplete="current-password" placeholder="••••••••" />
          </div>
          <div class="full">
            <button class="primary" id="loginBtn" type="button">Login</button>
            <div id="status" class="status"></div>
          </div>
        </div>
      </div>

      <div class="admin-area" id="adminArea">
        <div class="topbar">
          <div class="who">Signed in as <strong id="who"></strong></div>
          <div class="btnRow">
            <button class="secondary" id="refreshBtn2" type="button">Refresh</button>
            <button class="secondary" id="logoutBtn2" type="button">Logout</button>
          </div>
        </div>

        <h2>Boost purchases</h2>
        <div class="hint">Approve calls <code>approve_boost(uuid)</code>. Reject sets <code>status='rejected'</code>.</div>


        <div style="display:flex; gap:10px; align-items:center; margin: 8px 0 12px;">
          <label for="statusFilter" style="margin:0; font-size:12px; color: var(--muted);">Status</label>
          <select id="statusFilter" style="height: 36px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.06); color: var(--text); padding: 0 10px; font-size: 13px;">
            <option value="pending">pending</option>
            <option value="queued">queued</option>
            <option value="active">active</option>
            <option value="ended">ended</option>
            <option value="rejected">rejected</option>
            <option value="all">All</option>
          </select>
          <input id="searchBox" type="text" placeholder="Search (genre / placement / id)" style="flex:1; min-width: 220px; height: 36px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.06); color: var(--text); padding: 0 10px; font-size: 13px;" />
          <label style="display:flex; align-items:center; gap:6px; margin-left:6px; font-size:12px; color: var(--muted); white-space:nowrap;">
            <input id="autoRefreshToggle" type="checkbox" checked style="accent-color: var(--accent);" /> Auto-refresh
          </label>
          <button id="runSweepBtn" class="mini" title="Auto-end expired active boosts (based on created_at + duration_hours)">Run sweep</button>
          <span id="statusCount" style="margin-left:auto; font-size:12px; color: var(--muted2);"></span>
        </div>

        <div id="tableWrap"></div>
        <div id="adminStatus" class="status"></div>
      </div>
    </div>
  </div>

<script type="module">
  // Surface unexpected errors in the UI (helps debugging on GitHub Pages)
  window.addEventListener("error", (e) => {
    try {
      const el = document.getElementById("status");
      if (el) { el.classList.add("err"); el.textContent = "Error: " + (e?.message || e); }
    } catch {}
  });
  window.addEventListener("unhandledrejection", (e) => {
    try {
      const el = document.getElementById("status");
      if (el) { el.classList.add("err"); el.textContent = "Error: " + (e?.reason?.message || e?.reason || e); }
    } catch {}
  });

  import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

  const supa = createClient("https://otvznctmwutbwulbhfvx.supabase.co", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im90dnpuY3Rtd3V0Ynd1bGJoZnZ4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzIwNzc3MzcsImV4cCI6MjA4NzY1MzczN30.txShYO4rqLSMHeLuN_2rzRmvXZK3mnPsaabFtTa8Ph8");
  window.supa = supa;

  const loginArea = document.getElementById("loginArea");
  const adminArea = document.getElementById("adminArea");
  const headerBtns = document.getElementById("headerBtns");

  const statusEl = document.getElementById("status");
  const adminStatusEl = document.getElementById("adminStatus");
  const whoEl = document.getElementById("who");
  const tableWrap = document.getElementById("tableWrap");

  // Status filtering
  let currentStatusFilter = "pending"; // default preserves previous behavior
  const statusFilterEl = document.getElementById("statusFilter");
  const statusCountEl = document.getElementById("statusCount");

  let allRowsCache = [];
  let currentSearch = "";
  let autoRefreshEnabled = true;
  let autoRefreshTimer = null;

  const searchBoxEl = document.getElementById("searchBox");
  const autoRefreshToggleEl = document.getElementById("autoRefreshToggle");
  const runSweepBtnEl = document.getElementById("runSweepBtn");

  if (statusFilterEl) statusFilterEl.value = currentStatusFilter;
if (autoRefreshToggleEl) autoRefreshToggleEl.checked = true;

  const loginBtn = document.getElementById("loginBtn");

  const refreshBtns = [document.getElementById("refreshBtn"), document.getElementById("refreshBtn2")].filter(Boolean);
  const logoutBtns  = [document.getElementById("logoutBtn"),  document.getElementById("logoutBtn2")].filter(Boolean);

  function setStatus(msg, isErr=false) {
    statusEl.textContent = msg || "";
    statusEl.className = isErr ? "status err" : "status";
  }
  function setAdminStatus(msg, isErr=false) {
    adminStatusEl.textContent = msg || "";
    adminStatusEl.className = isErr ? "status err" : "status";
  }

  function esc(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#39;");
  }

  async function ensureAllowlisted() {
    const { data, error } = await supa.rpc("is_allowlisted_admin");
    if (error) throw new Error("Allowlist check failed: " + error.message);
    if (!data) throw new Error("not allowlisted");
  }

  async function callApproveBoost(purchaseId) {
    const paramAttempts = [
      { "purchase_id": purchaseId },
      { "p_purchase_id": purchaseId },
      { "id": purchaseId },
      { "boost_id": purchaseId },
    ];
    let lastErr = null;
    for (const params of paramAttempts) {
      const res = await supa.rpc("approve_boost", params);
      if (!res.error) return res;
      lastErr = res.error;
    }
    return { data: null, error: lastErr };
  }

  async function rejectBoost(purchaseId) {
    return await supa
      .from("boost_purchases")
      .update({ status: "rejected" })
      .eq("id", purchaseId)
      .select("id")
      .single();
  }

  async function activateBoost(purchaseId) {
    // Best-effort: flip queued -> active
    return await supa
      .from("boost_purchases")
      .update({ status: "active" })
      .eq("id", purchaseId)
      .select("id")
      .single();
  }

  async function endBoost(purchaseId) {
    // Best-effort: flip active -> ended
    return await supa
      .from("boost_purchases")
      .update({ status: "ended" })
      .eq("id", purchaseId)
      .select("id")
      .single();
  }

  function applyClientFilters() {
    const term = (currentSearch || "").trim().toLowerCase();
    let filtered = allRowsCache;

    if (term) {
      filtered = allRowsCache.filter(r => {
        const hay = [
          r.id,
          r.genre,
          r.placement,
          r.status,
          r.buyer_email,
          r.email,
          r.customer_email
        ].filter(Boolean).join(" ").toLowerCase();
        return hay.includes(term);
      });
    }

    renderTable(filtered);

    if (statusCountEl) {
      const count = filtered.length;
      statusCountEl.textContent = count + " result" + (count === 1 ? "" : "s");
    }
  }

  function startAutoRefresh() {
    stopAutoRefresh();
    if (!autoRefreshEnabled) return;
    // 15s refresh is enough to feel live without hammering Supabase
    autoRefreshTimer = setInterval(() => {
      loadBoosts();
    }, 15000);
  }

  function stopAutoRefresh() {
    if (autoRefreshTimer) {
      clearInterval(autoRefreshTimer);
      autoRefreshTimer = null;
    }
  }

  async function sweepExpiredActiveBoosts() {
    // Automated ending: if active and created_at + duration_hours has passed, set to ended.
    // This assumes created_at is the start timestamp (common lightweight approach).
    const { data, error } = await supa
      .from("boost_purchases")
      .select("id,created_at,duration_hours,status")
      .eq("status", "active")
      .order("created_at", { ascending: true })
      .limit(200);

    if (error) throw error;
    if (!data || data.length === 0) return;

    const now = Date.now();
    const expired = data.filter(r => {
      const start = Date.parse(r.created_at);
      const durMs = (Number(r.duration_hours) || 0) * 3600 * 1000;
      if (!start || !durMs) return false;
      return (start + durMs) <= now;
    });

    // Best-effort updates; if RLS prevents updates, they'll fail harmlessly.
    for (const r of expired) {
      await supa.from("boost_purchases").update({ status: "ended" }).eq("id", r.id);
    }
  }

  async function runAutomationSweep() {
    setAdminStatus("Running sweep…");
    try {
      await sweepExpiredActiveBoosts();
      await loadBoosts();
      setAdminStatus("Sweep complete.");
    } catch (err) {
      setAdminStatus("Sweep failed: " + (err?.message || String(err)), true);
    }
  }



  function renderTable(rows) {
    const label = (currentStatusFilter === 'all') ? 'purchases' : (currentStatusFilter + ' purchases');
    if (!rows || rows.length === 0) {
      tableWrap.innerHTML = "<div class='empty'>No " + esc(label) + ".</div>";
      if (statusCountEl) statusCountEl.textContent = "0 results";
      return;
    }

    const hasEmail = rows.some(r => (r.buyer_email || r.email || r.customer_email));

    tableWrap.innerHTML = `
      <table>
        <thead>
          <tr>
            <th>ID</th>
            ${hasEmail ? "<th>Email</th>" : ""}
            <th>Placement</th>
            <th>Genre</th>
            <th>Duration (hrs)</th>
            <th>Status</th>
            <th class="actionsCell">Actions</th>
          </tr>
        </thead>
        <tbody>
          ${
            rows.map(r => {
              const emailVal = r.buyer_email || r.email || r.customer_email || "";
              const status = (r.status || "").toLowerCase();
              const statusClass = ["pending","queued","active","ended","rejected"].includes(status) ? status : "all";
              const statusLabel = status || "—";

              const approveDisabled = status !== "pending";
              const rejectDisabled  = status !== "pending";
              const activateDisabled = status !== "queued";
              const endDisabled = status !== "active";

              const approveBtn = `<button class="primary mini" data-action="approve" data-id="${esc(r.id)}" ${approveDisabled ? "disabled title=\\"Only pending can be approved\\"" : ""}>Approve</button>`;
              const rejectBtn  = `<button class="mini danger" data-action="reject" data-id="${esc(r.id)}" ${rejectDisabled ? "disabled title=\\"Only pending can be rejected\\"" : ""}>Reject</button>`;
              const activateBtn = `<button class="mini" data-action="activate" data-id="${esc(r.id)}" ${activateDisabled ? "disabled title=\\"Only queued can be activated\\"" : ""}>Activate</button>`;
              const endBtn     = `<button class="mini danger" data-action="end" data-id="${esc(r.id)}" ${endDisabled ? "disabled title=\\"Only active can be ended\\"" : ""}>Force End</button>`;

              let actions = "";
              if (status === "pending") actions = approveBtn + " " + rejectBtn;
              else if (status === "queued") actions = activateBtn;
              else if (status === "active") actions = endBtn;
              else actions = `<span style="color:rgba(255,255,255,0.55); font-size:12px;">—</span>`;

              return `
                <tr>
                  <td>${esc(r.id)}</td>
                  ${hasEmail ? `<td>${emailVal ? esc(emailVal) : "<span style='color:rgba(255,255,255,0.55)'>—</span>"}</td>` : ""}
                  <td>${esc(r.placement) || "<span style='color:rgba(255,255,255,0.55)'>—</span>"}</td>
                  <td>${esc(r.genre) || "<span style='color:rgba(255,255,255,0.55)'>—</span>"}</td>
                  <td>${esc(r.duration_hours)}</td>
                  <td><span class="badge ${statusClass}"><span class="dot"></span>${esc(statusLabel)}</span></td>
                  <td class="actionsCell">${actions}</td>
                </tr>
              `;
            }).join("")
          }
        </tbody>
      </table>
    `;

    tableWrap.querySelectorAll("button[data-action]").forEach(btn => {
      btn.addEventListener("click", async (e) => {
        const action = e.currentTarget.getAttribute("data-action");
        const id = e.currentTarget.getAttribute("data-id");

        const buttons = tableWrap.querySelectorAll(`button[data-id="${CSS.escape(id)}"]`);
        buttons.forEach(b => b.disabled = true);

        try {
          if (action === "approve") {
            setAdminStatus("Approving " + id + "…");
            const res = await callApproveBoost(id);
            if (res.error) throw new Error(res.error.message);

            // Best-effort: immediately activate approved boosts if your RLS allows it.
            // If your workflow requires "queued" first, this will simply fail silently.
            try { await activateBoost(id); } catch (_) {}

            setAdminStatus("Approved " + id + ".");
          } else if (action === "reject") {
            setAdminStatus("Rejecting " + id + "…");
            const res = await rejectBoost(id);
            if (res.error) throw new Error(res.error.message);
            setAdminStatus("Rejected " + id + ".");
          } else if (action === "activate") {
            setAdminStatus("Activating " + id + "…");
            const res = await activateBoost(id);
            if (res.error) throw new Error(res.error.message);
            setAdminStatus("Activated " + id + ".");
          } else if (action === "end") {
            setAdminStatus("Ending " + id + "…");
            const res = await endBoost(id);
            if (res.error) throw new Error(res.error.message);
            setAdminStatus("Ended " + id + ".");
          }
          await loadBoosts();
        } catch (err) {
          setAdminStatus("Action failed: " + (err?.message || String(err)), true);
        } finally {
          // Don't re-enable disabled-by-status buttons.
          await loadBoosts();
        }
      });
    });
  }

  
async function loadBoosts() {
  const label = (currentStatusFilter === "all") ? "purchases" : (currentStatusFilter + " purchases");
  setAdminStatus("Loading " + label + "…");

  // Optional automation: end expired active boosts (best-effort, respects RLS)
  // Runs quietly; failures won't block loading.
  try { await sweepExpiredActiveBoosts(); } catch (_) {}

  let q = supa
    .from("boost_purchases")
    .select("*")
    .order("created_at", { ascending: false })
    .limit(200);

  if (currentStatusFilter !== "all") {
    q = q.eq("status", currentStatusFilter);
  }

  const { data, error } = await q;

  if (error) {
    setAdminStatus("Failed to load " + label + ": " + error.message, true);
    tableWrap.innerHTML = "";
    if (statusCountEl) statusCountEl.textContent = "";
    return;
  }

  allRowsCache = Array.isArray(data) ? data : [];
  applyClientFilters();

  const count = (allRowsCache?.length || 0);
  setAdminStatus("Loaded " + count + " " + label + ".");
}

  async function enterAdminUI() {
    const { data: { user } } = await supa.auth.getUser();
    whoEl.textContent = user?.email || "(unknown)";
    loginArea.style.display = "none";
    adminArea.style.display = "block";
    headerBtns.style.display = "flex";
    await loadBoosts();
    startAutoRefresh();
  }

  async function logout() {
    stopAutoRefresh();
    await supa.auth.signOut();
    adminArea.style.display = "none";
    headerBtns.style.display = "none";
    loginArea.style.display = "block";
    setStatus("Logged out.");
  }

  loginBtn.addEventListener("click", async () => {
    const email = document.getElementById("email").value.trim();
    const password = document.getElementById("password").value;

    setStatus("Logging in…");

    const { error } = await supa.auth.signInWithPassword({ email, password });
    if (error) { setStatus("Login failed: " + error.message, true); return; }

    try {
      setStatus("Checking allowlist…");
      await ensureAllowlisted();
      setStatus("✅ Allowlisted admin verified.");
      await enterAdminUI();
    } catch (e) {
      setStatus(String(e?.message || e), true);
    }
  });

  refreshBtns.forEach(b => b.addEventListener("click", loadBoosts));
  logoutBtns.forEach(b => b.addEventListener("click", logout));


  if (statusFilterEl) {
    statusFilterEl.addEventListener("change", async (e) => {
      currentStatusFilter = e.target.value;
      await loadBoosts();
    });
  }


  // Search (client-side on loaded rows)
  let searchDebounce = null;
  if (searchBoxEl) {
    searchBoxEl.addEventListener("input", (e) => {
      currentSearch = (e.target.value || "").trim().toLowerCase();
      clearTimeout(searchDebounce);
      searchDebounce = setTimeout(() => applyClientFilters(), 120);
    });
  }

  // Auto-refresh toggle
  if (autoRefreshToggleEl) {
    autoRefreshToggleEl.addEventListener("change", (e) => {
      autoRefreshEnabled = !!e.target.checked;
      if (autoRefreshEnabled) startAutoRefresh();
      else stopAutoRefresh();
    });
  }

  // Manual sweep button
  if (runSweepBtnEl) {
    runSweepBtnEl.addEventListener("click", async () => {
      await runAutomationSweep();
    });
  }


  // Auto-enter if already signed in
  (async () => {
    const { data: { session } } = await supa.auth.getSession();
    if (!session?.user) return;

    try {
      await ensureAllowlisted();
      await enterAdminUI();
    } catch (e) {
      setStatus(String(e?.message || e), true);
    }
  })();
</script>
</body>
</html>
